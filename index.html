<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>XeBin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="XeBin">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="XeBin">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="XeBin">
<meta name="twitter:description">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'> -->
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css"> -->
  <link href="//fonts.useso.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
  <link href='//fonts.useso.com/css?family=Open+Sans:300,600' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/style.css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <a href="/" class="logo">XeBin</a>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/xebin/index.html">About</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
        </div>
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
        
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/xebin" title="Fork me on GitHub"></a>
        
      </nav>
    </div>
  </div>
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
</header>

      <nav id="mobile-nav" class="off">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/xebin/index.html" class="mobile-nav-link">About</a>
  
  <div id="search-form-wrap-mobile">
    <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
  </div>
</nav>
      <div class="outer">
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">12</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/10/Jstorm学习总结/">Jstorm学习总结</a>
          </li>
        
          <li>
            <a href="/2016/04/07/python-设计模式/">python 设计模式</a>
          </li>
        
          <li>
            <a href="/2016/04/07/怎样才能敢说你熟悉python？/">怎样才能敢说你熟悉python？</a>
          </li>
        
          <li>
            <a href="/2016/04/06/ML数学基础/">ML数学基础</a>
          </li>
        
          <li>
            <a href="/2016/04/05/java读写文件/">java读写文件</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jstorm-ack-事务-流/">Jstorm ack 事务 流</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Jstorm-ack-事务-流/" style="font-size: 10px;">Jstorm ack 事务 流</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">links</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="http://hexo.io">Hexo</a>
          </li>
        
          <li>
            <a href="http://vonalex.github.io/">happen</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
        <section id="main">
  
    <article id="post-Jstorm学习总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/10/Jstorm学习总结/" class="article-date">
  <time datetime="2016-04-10T14:38:58.000Z" itemprop="datePublished">2016-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/10/Jstorm学习总结/">Jstorm学习总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一，storm如何保证数据不丢失？"><a href="#一，storm如何保证数据不丢失？" class="headerlink" title="一，storm如何保证数据不丢失？"></a>一，storm如何保证数据不丢失？</h3><ul>
<li><h4 id="storm是通过ack机制来保证数据不丢失，下面以一个简单的例子讲一下ack机制，见下图："><a href="#storm是通过ack机制来保证数据不丢失，下面以一个简单的例子讲一下ack机制，见下图：" class="headerlink" title="storm是通过ack机制来保证数据不丢失，下面以一个简单的例子讲一下ack机制，见下图："></a>storm是通过ack机制来保证数据不丢失，下面以一个简单的例子讲一下ack机制，见下图：</h4><p><img src="http://7xskxa.com2.z0.glb.clouddn.com/ack%E6%A1%86%E6%9E%B6%E4%BE%8B%E5%AD%90.jpg" alt="ack框架例子"></p>
<pre><code>具体过程讲解：
</code></pre><p><img src="http://7xskxa.com2.z0.glb.clouddn.com/ack%E6%AD%A5%E9%AA%A4.jpg" alt="ack步骤"></p>
</li>
</ul>
<h3 id="二，事务"><a href="#二，事务" class="headerlink" title="二，事务"></a>二，事务</h3><pre><code>storm的事务主要用于，对数据准确性非常高的环境中。它保证了在处理消息的过程中，消息不会丢失，而且再结合具有去重功的存储，就可以实现消息被整个系统处理一次而且只处理一次。
事务的设计模式主要有：
1，strong order：强顺序流； 
2，强顺序batch流：一次处理一批turple，而且当一个batch处理完，才会处理下一个batch
3，Trasactional Topology： Storm提供的Transactional Topology将batch计算分为process和commit两个阶段。Process阶段可以同时处理多个batch，不用保证顺序性；commit阶段保证batch的强顺序性，并且一次只能处理一个batch，第1个batch成功提交之前，第2个batch不能被提交。
</code></pre><h3 id="三，数据流分流与合并"><a href="#三，数据流分流与合并" class="headerlink" title="三，数据流分流与合并"></a>三，数据流分流与合并</h3><p>参考： <a href="https://github.com/alibaba/jstorm/wiki/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%B5%81%E5%92%8C%E5%90%88%E5%B9%B6" target="_blank" rel="external">https://github.com/alibaba/jstorm/wiki/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%B5%81%E5%92%8C%E5%90%88%E5%B9%B6</a></p>
<h3 id="四，"><a href="#四，" class="headerlink" title="四，"></a>四，</h3><h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h5><p>1，<a href="https://github.com/alibaba/jstorm/wiki/JStorm-Chinese-Documentation" target="_blank" rel="external">Jstorm document</a><br>2，storm源码解析 李明<br>3，<a href="http://blog.linezing.com/?p=1976" target="_blank" rel="external">http://blog.linezing.com/?p=1976</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/10/Jstorm学习总结/" data-id="cimuooa7n00005ieltl2qb5k1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jstorm-ack-事务-流/">Jstorm ack 事务 流</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-python-设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/python-设计模式/" class="article-date">
  <time datetime="2016-04-07T15:10:09.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/python-设计模式/">python 设计模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python设计模式"><a href="#Python设计模式" class="headerlink" title="Python设计模式"></a>Python设计模式</h1><p>代码直戳: <a href="https://github.com/faif/python-patterns" target="_blank" rel="external">https://github.com/faif/python-patterns</a></p>
<h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h2><p>实例 -&gt; 类 -&gt; 类工厂</p>
<h2 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h2><p>简单来说就是把一些具有相同方法的类再进行封装,抽象共同的方法以供调用.是工厂方法的进阶版本.</p>
<p>实例 -&gt; 类 -&gt; 类工厂 -&gt; 抽象工厂</p>
<h2 id="惰性初始化-Lazy-evaluation"><a href="#惰性初始化-Lazy-evaluation" class="headerlink" title="惰性初始化 Lazy evaluation"></a>惰性初始化 Lazy evaluation</h2><p>这个Python里可以使用@property实现,就是当调用的时候才生成.</p>
<h2 id="生成器-Builder"><a href="#生成器-Builder" class="headerlink" title="生成器 Builder"></a>生成器 Builder</h2><p><img src="img/builder.png" alt=""></p>
<p>Builder模式主要用于构建一个复杂的对象，但这个对象构建的算法是稳定的，对象中的各个部分经常变化。Builder模式主要在于应对复杂对象各个部分的频繁需求变动。但是难以应对算法的需求变动。这点一定要注意，如果用错了，会带来很多不必要的麻烦。</p>
<p>重点是将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。</p>
<p>简单的说：子对象变化较频繁，对算法相对稳定。</p>
<h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式 Singleton"></a>单例模式 Singleton</h2><p>一个类只有一个实例</p>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>特点是通过复制一个已经存在的实例来返回新的实例,而不是新建实例.</p>
<p>多用于创建复杂的或者耗时的实例,因为这种情况下,复制一个已经存在的实例使程序运行更高效;或者创建值相等,只是命名不一样的同类数据.</p>
<h2 id="对象池-Object-pool"><a href="#对象池-Object-pool" class="headerlink" title="对象池 Object pool"></a>对象池 Object pool</h2><p>一个对象池是一组已经初始化过且可以使用的对象，而可以不用在有需求时创建和销毁对象。池的用户可以从池子中取得对象，对其进行操作处理，并在不需要时归还给池子而非销毁 而不是销毁它. </p>
<p>在Python内部实现了对象池技术.例如像小整型这样的数据引用非常多,创建销毁都会消耗时间,所以保存在对象池里,减少开销.</p>
<h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="修饰模型-Decorator"><a href="#修饰模型-Decorator" class="headerlink" title="修饰模型 Decorator"></a>修饰模型 Decorator</h2><p>Python里就是装饰器.</p>
<h2 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式 Proxy"></a>代理模式 Proxy</h2><p>例如Python里的引用计数.</p>
<h1 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h1><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代容器里所有的元素.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/python-设计模式/" data-id="cimuooa8e00085ielqqqikeki" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-怎样才能敢说你熟悉python？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/07/怎样才能敢说你熟悉python？/" class="article-date">
  <time datetime="2016-04-07T14:39:59.000Z" itemprop="datePublished">2016-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/07/怎样才能敢说你熟悉python？/">怎样才能敢说你熟悉python？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="怎样才能敢说你熟悉python？"><a href="#怎样才能敢说你熟悉python？" class="headerlink" title="怎样才能敢说你熟悉python？"></a>怎样才能敢说你熟悉python？</h3><ul>
<li><h4 id="感谢宿舍大神的整理推荐！"><a href="#感谢宿舍大神的整理推荐！" class="headerlink" title="感谢宿舍大神的整理推荐！"></a>感谢宿舍大神的整理推荐！</h4><pre><code>见：https://github.com/Xebin/interview_python
</code></pre></li>
</ul>
<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="#python语言特性">Python语言特性</a><ul>
<li><a href="#1-python的函数参数传递">1 Python的函数参数传递</a></li>
<li><a href="#2-python中的元类metaclass">2 Python中的元类(metaclass)</a></li>
<li><a href="#3-staticmethod和classmethod">3 @staticmethod和@classmethod</a></li>
<li><a href="#4-类变量和实例变量">4 类变量和实例变量</a></li>
<li><a href="#5-python自省">5 Python自省</a></li>
<li><a href="#6-字典推导式">6 字典推导式</a></li>
<li><a href="#7-python中单下划线和双下划线">7 Python中单下划线和双下划线</a></li>
<li><a href="#8-字符串格式化和format">8 字符串格式化:%和.format</a></li>
<li><a href="#9-迭代器和生成器">9 迭代器和生成器</a></li>
<li><a href="#10-args-and-kwargs">10 <code>*args</code> and <code>**kwargs</code></a></li>
<li><a href="#11-面向切面编程aop和装饰器">11 面向切面编程AOP和装饰器</a></li>
<li><a href="#12-鸭子类型">12 鸭子类型</a></li>
<li><a href="#13-python中重载">13 Python中重载</a></li>
<li><a href="#14-新式类和旧式类">14 新式类和旧式类</a></li>
<li><a href="#15-__new__和__init__的区别">15 <code>__new__</code>和<code>__init__</code>的区别</a></li>
<li><a href="#16-单例模式">16 单例模式</a><ul>
<li><a href="#1-使用__new__方法">1 使用<code>__new__</code>方法</a></li>
<li><a href="#2-共享属性">2 共享属性</a></li>
<li><a href="#3-装饰器版本">3 装饰器版本</a></li>
<li><a href="#4-import方法">4 import方法</a></li>
</ul>
</li>
<li><a href="#17-python中的作用域">17 Python中的作用域</a></li>
<li><a href="#18-gil线程全局锁">18 GIL线程全局锁</a></li>
<li><a href="#19-协程">19 协程</a></li>
<li><a href="#20-闭包">20 闭包</a></li>
<li><a href="#21-lambda函数">21 lambda函数</a></li>
<li><a href="#22-python函数式编程">22 Python函数式编程</a></li>
<li><a href="#23-python里的拷贝">23 Python里的拷贝</a></li>
<li><a href="#24-python垃圾回收机制">24 Python垃圾回收机制</a><ul>
<li><a href="#1-引用计数">1 引用计数</a></li>
<li><a href="#2-标记-清除机制">2 标记-清除机制</a></li>
<li><a href="#3-分代技术">3 分代技术</a></li>
</ul>
</li>
<li><a href="#25-python的list">25 Python的List</a></li>
<li><a href="#26-python的is">26 Python的is</a></li>
<li><a href="#27-readreadline和readlines">27 read,readline和readlines</a></li>
<li><a href="#28-python2和3的区别">28 Python2和3的区别</a></li>
</ul>
</li>
<li><a href="#操作系统">操作系统</a><ul>
<li><a href="#1-selectpoll和epoll">1 select,poll和epoll</a></li>
<li><a href="#2-调度算法">2 调度算法</a></li>
<li><a href="#3-死锁">3 死锁</a></li>
<li><a href="#4-程序编译与链接">4 程序编译与链接</a><ul>
<li><a href="#1-预处理">1 预处理</a></li>
<li><a href="#2-编译">2 编译</a></li>
<li><a href="#3-汇编">3 汇编</a></li>
<li><a href="#4-链接">4 链接</a></li>
</ul>
</li>
<li><a href="#5-静态链接和动态链接">5 静态链接和动态链接</a></li>
<li><a href="#6-虚拟内存技术">6 虚拟内存技术</a></li>
<li><a href="#7-分页和分段">7 分页和分段</a><ul>
<li><a href="#分页与分段的主要区别">分页与分段的主要区别</a></li>
</ul>
</li>
<li><a href="#8-页面置换算法">8 页面置换算法</a></li>
<li><a href="#9-边沿触发和水平触发">9 边沿触发和水平触发</a></li>
</ul>
</li>
<li><a href="#数据库">数据库</a><ul>
<li><a href="#1-事务">1 事务</a></li>
<li><a href="#2-数据库索引">2 数据库索引</a></li>
<li><a href="#3-redis原理">3 Redis原理</a></li>
<li><a href="#4-乐观锁和悲观锁">4 乐观锁和悲观锁</a></li>
<li><a href="#5-mvcc">5 MVCC</a></li>
<li><a href="#6-myisam和innodb">6 MyISAM和InnoDB</a></li>
</ul>
</li>
<li><a href="#网络">网络</a><ul>
<li><a href="#1-三次握手">1 三次握手</a></li>
<li><a href="#2-四次挥手">2 四次挥手</a></li>
<li><a href="#3-arp协议">3 ARP协议</a></li>
<li><a href="#4-urllib和urllib2的区别">4 urllib和urllib2的区别</a></li>
<li><a href="#5-post和get">5 Post和Get</a></li>
<li><a href="#6-cookie和session">6 Cookie和Session</a></li>
<li><a href="#7-apache和nginx的区别">7 apache和nginx的区别</a></li>
<li><a href="#8-网站用户密码保存">8 网站用户密码保存</a></li>
<li><a href="#9-http和https">9 HTTP和HTTPS</a></li>
<li><a href="#10-xsrf和xss">10 XSRF和XSS</a></li>
<li><a href="#11-幂等-idempotence">11 幂等 Idempotence</a></li>
<li><a href="#12-restful架构soaprpc">12 RESTful架构(SOAP,RPC)</a></li>
<li><a href="#13-soap">13 SOAP</a></li>
<li><a href="#14-rpc">14 RPC</a></li>
<li><a href="#15-cgi和wsgi">15 CGI和WSGI</a></li>
<li><a href="#16-中间人攻击">16 中间人攻击</a></li>
<li><a href="#17-c10k问题">17 c10k问题</a></li>
<li><a href="#18-socket">18 socket</a></li>
<li><a href="#19-浏览器缓存">19 浏览器缓存</a></li>
<li><a href="#20-http10和http11">20 HTTP1.0和HTTP1.1</a></li>
<li><a href="#21-ajax">21 Ajax</a></li>
</ul>
</li>
<li><a href="#nix">*NIX</a><ul>
<li><a href="#unixipc">unix进程间通信方式(IPC)</a></li>
</ul>
</li>
<li><a href="#数据结构">数据结构</a><ul>
<li><a href="#1-红黑树">1 红黑树</a></li>
</ul>
</li>
<li><a href="#编程题">编程题</a><ul>
<li><a href="#1-台阶问题斐波纳挈">1 台阶问题/斐波纳挈</a></li>
<li><a href="#2-变态台阶问题">2 变态台阶问题</a></li>
<li><a href="#3-矩形覆盖">3 矩形覆盖</a></li>
<li><a href="#4-杨氏矩阵查找">4 杨氏矩阵查找</a></li>
<li><a href="#5-去除列表中的重复元素">5 去除列表中的重复元素</a></li>
<li><a href="#6-链表成对调换">6 链表成对调换</a></li>
<li><a href="#7-创建字典的方法">7 创建字典的方法</a><ul>
<li><a href="#1-直接创建">1 直接创建</a></li>
<li><a href="#2-工厂方法">2 工厂方法</a></li>
<li><a href="#3-fromkeys方法">3 fromkeys()方法</a></li>
</ul>
</li>
<li><a href="#8-合并两个有序列表">8 合并两个有序列表</a></li>
<li><a href="#9-交叉链表求交点">9 交叉链表求交点</a></li>
<li><a href="#10-二分查找">10 二分查找</a></li>
<li><a href="#11-快排">11 快排</a></li>
<li><a href="#12-找零问题">12 找零问题</a></li>
<li><a href="#13-广度遍历和深度遍历二叉树">13 广度遍历和深度遍历二叉树</a></li>
<li><a href="#14-">14 二叉树节点</a></li>
<li><a href="#15-">15 层次遍历</a></li>
<li><a href="#16-">16 深度遍历</a></li>
<li><a href="#17-前中后序遍历">17 前中后序遍历</a></li>
<li><a href="#18-求最大树深">18 求最大树深</a></li>
<li><a href="#19-求两棵树是否相同">19 求两棵树是否相同</a></li>
<li><a href="#20-前序中序求后序">20 前序中序求后序</a></li>
<li><a href="#21-单链表逆置">21 单链表逆置</a></li>
</ul>
</li>
</ul>
<!-- markdown-toc end -->
<h1 id="Python语言特性"><a href="#Python语言特性" class="headerlink" title="Python语言特性"></a>Python语言特性</h1><h2 id="1-Python的函数参数传递"><a href="#1-Python的函数参数传递" class="headerlink" title="1 Python的函数参数传递"></a>1 Python的函数参数传递</h2><p>看两个例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(a)</span>:</span></span><br><span class="line">    a.append(<span class="number">1</span>)</span><br><span class="line">fun(a)</span><br><span class="line"><span class="keyword">print</span> a  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。</p>
<p>这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而list,dict等则是可以修改的对象。(这就是这个问题的重点)</p>
<p>当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改.</p>
<p>如果还不明白的话,这里有更好的解释: <a href="http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference" target="_blank" rel="external">http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference</a></p>
<h2 id="2-Python中的元类-metaclass"><a href="#2-Python中的元类-metaclass" class="headerlink" title="2 Python中的元类(metaclass)"></a>2 Python中的元类(metaclass)</h2><p>这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:<a href="http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python</a></p>
<h2 id="3-staticmethod和-classmethod"><a href="#3-staticmethod和-classmethod" class="headerlink" title="3 @staticmethod和@classmethod"></a>3 @staticmethod和@classmethod</h2><p>Python其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"executing foo(%s)"</span>%(x)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing foo(%s,%s)"</span>%(self,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls,x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing class_foo(%s,%s)"</span>%(cls,x)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"executing static_foo(%s)"</span>%x</span><br><span class="line"></span><br><span class="line">a=A()</span><br></pre></td></tr></table></figure>
<p>这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用<code>foo(x)</code>,这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是<code>foo(self, x)</code>,为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的<code>a.foo(x)</code>(其实是<code>foo(a, x)</code>).类方法一样,只不过它传递的是类而不是实例,<code>A.class_foo(x)</code>.注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好.</p>
<p>对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用<code>a.static_foo(x)</code>或者<code>A.static_foo(x)</code>来调用.</p>
<table>
<thead>
<tr>
<th style="text-align:left">\</th>
<th style="text-align:left">实例方法</th>
<th style="text-align:left">类方法</th>
<th style="text-align:left">静态方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a = A()</td>
<td style="text-align:left">a.foo(x)</td>
<td style="text-align:left">a.class_foo(x)</td>
<td style="text-align:left">a.static_foo(x)</td>
</tr>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:left">不可用</td>
<td style="text-align:left">A.class_foo(x)</td>
<td style="text-align:left">A.static_foo(x)</td>
</tr>
</tbody>
</table>
<p>更多关于这个问题:<a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a></p>
<h2 id="4-类变量和实例变量"><a href="#4-类变量和实例变量" class="headerlink" title="4 类变量和实例变量"></a>4 类变量和实例变量</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=<span class="string">"aaa"</span></span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name=<span class="string">"bbb"</span></span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># bbb</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># aaa</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># aaa</span></span><br></pre></td></tr></table></figure>
<p>类变量就是供类使用的变量,实例变量就是供实例使用的.</p>
<p>这里<code>p1.name=&quot;bbb&quot;</code>是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,<code>p1.name</code>一开始是指向的类变量<code>name=&quot;aaa&quot;</code>,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了.</p>
<p>可以看看下面的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    name=[]</span><br><span class="line"></span><br><span class="line">p1=Person()</span><br><span class="line">p2=Person()</span><br><span class="line">p1.name.append(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">print</span> p1.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> p2.name  <span class="comment"># [1]</span></span><br><span class="line"><span class="keyword">print</span> Person.name  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>
<p>参考:<a href="http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block" target="_blank" rel="external">http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block</a></p>
<h2 id="5-Python自省"><a href="#5-Python自省" class="headerlink" title="5 Python自省"></a>5 Python自省</h2><p>这个也是python彪悍的特性.</p>
<p>自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().</p>
<h2 id="6-字典推导式"><a href="#6-字典推导式" class="headerlink" title="6 字典推导式"></a>6 字典推导式</h2><p>可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;key: value <span class="keyword">for</span> (key, value) <span class="keyword">in</span> iterable&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-Python中单下划线和双下划线"><a href="#7-Python中单下划线和双下划线" class="headerlink" title="7 Python中单下划线和双下划线"></a>7 Python中单下划线和双下划线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            self.__superprivate = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">... </span>            self._semiprivate = <span class="string">", world!"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mc = MyClass()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__superprivate</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: myClass instance has no attribute <span class="string">'__superprivate'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc._semiprivate</span><br><span class="line">, world!</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> mc.__dict__</span><br><span class="line">&#123;<span class="string">'_MyClass__superprivate'</span>: <span class="string">'Hello'</span>, <span class="string">'_semiprivate'</span>: <span class="string">', world!'</span>&#125;</span><br></pre></td></tr></table></figure>
<p><code>__foo__</code>:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突.</p>
<p><code>_foo</code>:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.</p>
<p><code>__foo</code>:这个有真正的意义:解析器用<code>_classname__foo</code>来代替这个名字,以区别和其他类相同的命名.</p>
<p>详情见:<a href="http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python</a></p>
<p>或者: <a href="http://www.zhihu.com/question/19754941" target="_blank" rel="external">http://www.zhihu.com/question/19754941</a></p>
<h2 id="8-字符串格式化-和-format"><a href="#8-字符串格式化-和-format" class="headerlink" title="8 字符串格式化:%和.format"></a>8 字符串格式化:%和.format</h2><p>.format在许多方面看起来更便利.对于<code>%</code>最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % name</span><br></pre></td></tr></table></figure>
<p>但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hi there %s&quot; % (name,)   # 提供一个单元素的数组而不是一个参数</span><br></pre></td></tr></table></figure>
<p>但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了.</p>
<p>你为什么不用它?</p>
<ul>
<li>不知道它(在读这个之前)</li>
<li>为了和Python2.5兼容(譬如logging库建议使用<code>%</code>(<a href="https://github.com/taizilongxu/interview_python/issues/4" target="_blank" rel="external">issue #4</a>))</li>
</ul>
<p><a href="http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format" target="_blank" rel="external">http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format</a></p>
<h2 id="9-迭代器和生成器"><a href="#9-迭代器和生成器" class="headerlink" title="9 迭代器和生成器"></a>9 迭代器和生成器</h2><p>这个是stackoverflow里python排名第一的问题,值得一看: <a href="http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python</a></p>
<p>这是中文版: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html" target="_blank" rel="external">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html</a></p>
<h2 id="10-args-and-kwargs"><a href="#10-args-and-kwargs" class="headerlink" title="10 *args and **kwargs"></a>10 <code>*args</code> and <code>**kwargs</code></h2><p>用<code>*args</code>和<code>**kwargs</code>只是为了方便并没有强制使用它们.</p>
<p>当你不确定你的函数里将要传递多少参数时你可以用<code>*args</code>.例如,它可以传递任意数量的参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_everything</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> count, thing <span class="keyword">in</span> enumerate(args):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125;. &#123;1&#125;'</span>.format(count, thing)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_everything(<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'cabbage'</span>)</span><br><span class="line"><span class="number">0.</span> apple</span><br><span class="line"><span class="number">1.</span> banana</span><br><span class="line"><span class="number">2.</span> cabbage</span><br></pre></td></tr></table></figure>
<p>相似的,<code>**kwargs</code>允许你使用没有事先定义的参数名:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">table_things</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> name, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">'&#123;0&#125; = &#123;1&#125;'</span>.format(name, value)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>table_things(apple = <span class="string">'fruit'</span>, cabbage = <span class="string">'vegetable'</span>)</span><br><span class="line">cabbage = vegetable</span><br><span class="line">apple = fruit</span><br></pre></td></tr></table></figure>
<p>你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给<code>*args</code>和<code>**kwargs</code>.命名参数在列表的最前端.例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def table_things(titlestring, **kwargs)</span><br></pre></td></tr></table></figure>
<p><code>*args</code>和<code>**kwargs</code>可以同时在函数的定义中,但是<code>*args</code>必须在<code>**kwargs</code>前面.</p>
<p>当调用函数时你也可以用<code>*</code>和<code>**</code>语法.例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">print_three_things</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'</span>.format(a,b,c)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="string">'aardvark'</span>, <span class="string">'baboon'</span>, <span class="string">'cat'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_three_things(*mylist)</span><br><span class="line"></span><br><span class="line">a = aardvark, b = baboon, c = cat</span><br></pre></td></tr></table></figure>
<p>就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*.</p>
<p><a href="http://stackoverflow.com/questions/3394835/args-and-kwargs" target="_blank" rel="external">http://stackoverflow.com/questions/3394835/args-and-kwargs</a></p>
<h2 id="11-面向切面编程AOP和装饰器"><a href="#11-面向切面编程AOP和装饰器" class="headerlink" title="11 面向切面编程AOP和装饰器"></a>11 面向切面编程AOP和装饰器</h2><p>这个AOP一听起来有点懵,同学面阿里的时候就被问懵了…</p>
<p>装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，<strong>装饰器的作用就是为已经存在的对象添加额外的功能。</strong></p>
<p>这个问题比较大,推荐: <a href="http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python" target="_blank" rel="external">http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python</a></p>
<p>中文: <a href="http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html" target="_blank" rel="external">http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html</a></p>
<h2 id="12-鸭子类型"><a href="#12-鸭子类型" class="headerlink" title="12 鸭子类型"></a>12 鸭子类型</h2><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p>
<p>我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。</p>
<p>比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。</p>
<p>又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.</p>
<p>鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。</p>
<h2 id="13-Python中重载"><a href="#13-Python中重载" class="headerlink" title="13 Python中重载"></a>13 Python中重载</h2><p>引自知乎:<a href="http://www.zhihu.com/question/20053359" target="_blank" rel="external">http://www.zhihu.com/question/20053359</a></p>
<p>函数重载主要是为了解决两个问题。</p>
<ol>
<li>可变参数类型。</li>
<li>可变参数个数。</li>
</ol>
<p>另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。</p>
<p>好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。</p>
<p>那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。</p>
<p>好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。</p>
<h2 id="14-新式类和旧式类"><a href="#14-新式类和旧式类" class="headerlink" title="14 新式类和旧式类"></a>14 新式类和旧式类</h2><p>这个面试官问了,我说了老半天,不知道他问的真正意图是什么.</p>
<p><a href="http://stackoverflow.com/questions/54867/what-is-the-difference-between-old-style-and-new-style-classes-in-python" target="_blank" rel="external">stackoverflow</a></p>
<p>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="external">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></p>
<p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),<python核心编程>里讲的也很多.</python核心编程></p>
<h2 id="15-new-和-init-的区别"><a href="#15-new-和-init-的区别" class="headerlink" title="15 __new__和__init__的区别"></a>15 <code>__new__</code>和<code>__init__</code>的区别</h2><p>这个<code>__new__</code>确实很少见到,先做了解吧.</p>
<ol>
<li><code>__new__</code>是一个静态方法,而<code>__init__</code>是一个实例方法.</li>
<li><code>__new__</code>方法会返回一个创建的实例,而<code>__init__</code>什么都不返回.</li>
<li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li>
<li>当创建一个新实例时调用<code>__new__</code>,初始化一个实例时用<code>__init__</code>.</li>
</ol>
<p><a href="http://stackoverflow.com/questions/674304/pythons-use-of-new-and-init" target="_blank" rel="external">stackoverflow</a></p>
<p>ps: <code>__metaclass__</code>是创建类时起作用.所以我们可以分别使用<code>__metaclass__</code>,<code>__new__</code>和<code>__init__</code>来分别在类创建,实例创建和实例初始化的时候做一些小手脚.</p>
<h2 id="16-单例模式"><a href="#16-单例模式" class="headerlink" title="16 单例模式"></a>16 单例模式</h2><p>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</p>
<h3 id="1-使用-new-方法"><a href="#1-使用-new-方法" class="headerlink" title="1 使用__new__方法"></a>1 使用<code>__new__</code>方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="2-共享属性"><a href="#2-共享属性" class="headerlink" title="2 共享属性"></a>2 共享属性</h3><p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-装饰器版本"><a href="#3-装饰器版本" class="headerlink" title="3 装饰器版本"></a>3 装饰器版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getinstance</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> getinstance</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<h3 id="4-import方法"><a href="#4-import方法" class="headerlink" title="4 import方法"></a>4 import方法</h3><p>作为python的模块是天然的单例模式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mysingleton.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">My_Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">my_singleton = My_Singleton()</span><br><span class="line"></span><br><span class="line"><span class="comment"># to use</span></span><br><span class="line"><span class="keyword">from</span> mysingleton <span class="keyword">import</span> my_singleton</span><br><span class="line"></span><br><span class="line">my_singleton.foo()</span><br></pre></td></tr></table></figure>
<h2 id="17-Python中的作用域"><a href="#17-Python中的作用域" class="headerlink" title="17 Python中的作用域"></a>17 Python中的作用域</h2><p>Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。</p>
<p>当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：</p>
<p>本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）</p>
<h2 id="18-GIL线程全局锁"><a href="#18-GIL线程全局锁" class="headerlink" title="18 GIL线程全局锁"></a>18 GIL线程全局锁</h2><p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.</p>
<p>见<a href="http://www.oschina.net/translate/pythons-hardest-problem" target="_blank" rel="external">Python 最难的问题</a></p>
<p>解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).</p>
<h2 id="19-协程"><a href="#19-协程" class="headerlink" title="19 协程"></a>19 协程</h2><p>知乎被问到了,呵呵哒,跪了</p>
<p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p>
<p>Python里最常见的yield就是协程的思想!可以查看第九个问题.</p>
<h2 id="20-闭包"><a href="#20-闭包" class="headerlink" title="20 闭包"></a>20 闭包</h2><p>闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。</p>
<p>当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:</p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ol>
<p>感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.</p>
<p>重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.</p>
<p>闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.</p>
<h2 id="21-lambda函数"><a href="#21-lambda函数" class="headerlink" title="21 lambda函数"></a>21 lambda函数</h2><p>其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关.</p>
<p>推荐: <a href="http://www.zhihu.com/question/20125256" target="_blank" rel="external">知乎</a></p>
<h2 id="22-Python函数式编程"><a href="#22-Python函数式编程" class="headerlink" title="22 Python函数式编程"></a>22 Python函数式编程</h2><p>这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用.</p>
<p>推荐: <a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="external">酷壳</a></p>
<p>python中函数式编程支持:</p>
<p>filter 函数的功能相当于过滤器。调用一个布尔函数<code>bool_func</code>来迭代遍历每个seq中的元素；返回一个使<code>bool_seq</code>返回值为true的元素的序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">&gt;&gt;&gt;b = filter(<span class="keyword">lambda</span> x: x &gt; <span class="number">5</span>, a)</span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> b</span><br><span class="line">&gt;&gt;&gt;[<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = map(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a)</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:x*y,range(<span class="number">1</span>,<span class="number">4</span>))</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="23-Python里的拷贝"><a href="#23-Python里的拷贝" class="headerlink" title="23 Python里的拷贝"></a>23 Python里的拷贝</h2><p>引用和copy(),deepcopy()的区别</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]  <span class="comment">#原始对象</span></span><br><span class="line"></span><br><span class="line">b = a  <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)  <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)  <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>)  <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>)  <span class="comment">#修改对象a中的['a', 'b']数组对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'a = '</span>, a</span><br><span class="line"><span class="keyword">print</span> <span class="string">'b = '</span>, b</span><br><span class="line"><span class="keyword">print</span> <span class="string">'c = '</span>, c</span><br><span class="line"><span class="keyword">print</span> <span class="string">'d = '</span>, d</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="24-Python垃圾回收机制"><a href="#24-Python垃圾回收机制" class="headerlink" title="24 Python垃圾回收机制"></a>24 Python垃圾回收机制</h2><p>Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。</p>
<h3 id="1-引用计数"><a href="#1-引用计数" class="headerlink" title="1 引用计数"></a>1 引用计数</h3><p>PyObject是每个对象必有的内容，其中<code>ob_refcnt</code>就是做为引用计数。当一个对象有新的引用时，它的<code>ob_refcnt</code>就会增加，当引用它的对象被删除，它的<code>ob_refcnt</code>就会减少.引用计数为0时，该对象生命就结束了。</p>
<p>优点:</p>
<ol>
<li>简单</li>
<li>实时性</li>
</ol>
<p>缺点:</p>
<ol>
<li>维护引用计数消耗资源</li>
<li>循环引用</li>
</ol>
<h3 id="2-标记-清除机制"><a href="#2-标记-清除机制" class="headerlink" title="2 标记-清除机制"></a>2 标记-清除机制</h3><p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<h3 id="3-分代技术"><a href="#3-分代技术" class="headerlink" title="3 分代技术"></a>3 分代技术</h3><p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。</p>
<p>举例：<br>当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p>
<h2 id="25-Python的List"><a href="#25-Python的List" class="headerlink" title="25 Python的List"></a>25 Python的List</h2><p>推荐: <a href="http://www.jianshu.com/p/J4U6rR" target="_blank" rel="external">http://www.jianshu.com/p/J4U6rR</a></p>
<h2 id="26-Python的is"><a href="#26-Python的is" class="headerlink" title="26 Python的is"></a>26 Python的is</h2><p>is是对比地址,==是对比值</p>
<h2 id="27-read-readline和readlines"><a href="#27-read-readline和readlines" class="headerlink" title="27 read,readline和readlines"></a>27 read,readline和readlines</h2><ul>
<li>read        读取整个文件</li>
<li>readline    读取下一行,使用生成器方法</li>
<li>readlines   读取整个文件到一个迭代器以供我们遍历</li>
</ul>
<h2 id="28-Python2和3的区别"><a href="#28-Python2和3的区别" class="headerlink" title="28 Python2和3的区别"></a>28 Python2和3的区别</h2><p>推荐：<a href="http://chenqx.github.io/2014/11/10/Key-differences-between-Python-2-7-x-and-Python-3-x/" target="_blank" rel="external">Python 2.7.x 与 Python 3.x 的主要差异</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="1-select-poll和epoll"><a href="#1-select-poll和epoll" class="headerlink" title="1 select,poll和epoll"></a>1 select,poll和epoll</h2><p>其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了.</p>
<p>这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的.</p>
<p><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="external">selec,poll和epoll区别总结</a></p>
<p>基本上select有3个缺点:</p>
<ol>
<li>连接数受限</li>
<li>查找配对速度慢</li>
<li>数据由内核拷贝到用户态</li>
</ol>
<p>poll改善了第一个缺点</p>
<p>epoll改了三个缺点.</p>
<p>关于epoll的: <a href="http://www.cnblogs.com/my_life/articles/3968782.html" target="_blank" rel="external">http://www.cnblogs.com/my_life/articles/3968782.html</a></p>
<h2 id="2-调度算法"><a href="#2-调度算法" class="headerlink" title="2 调度算法"></a>2 调度算法</h2><ol>
<li>先来先服务(FCFS, First Come First Serve)</li>
<li>短作业优先(SJF, Shortest Job First)</li>
<li>最高优先权调度(Priority Scheduling)</li>
<li>时间片轮转(RR, Round Robin)</li>
<li>多级反馈队列调度(multilevel feedback queue scheduling)</li>
</ol>
<p>实时调度算法:</p>
<ol>
<li>最早截至时间优先 EDF</li>
<li>最低松弛度优先 LLF</li>
</ol>
<h2 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3 死锁"></a>3 死锁</h2><p>原因:</p>
<ol>
<li>竞争资源</li>
<li>程序推进顺序不当</li>
</ol>
<p>必要条件:</p>
<ol>
<li>互斥条件</li>
<li>请求和保持条件</li>
<li>不剥夺条件</li>
<li>环路等待条件</li>
</ol>
<p>处理死锁基本方法:</p>
<ol>
<li>预防死锁(摒弃除1以外的条件)</li>
<li>避免死锁(银行家算法)</li>
<li>检测死锁(资源分配图)</li>
<li>解除死锁<ol>
<li>剥夺资源</li>
<li>撤销进程</li>
</ol>
</li>
</ol>
<h2 id="4-程序编译与链接"><a href="#4-程序编译与链接" class="headerlink" title="4 程序编译与链接"></a>4 程序编译与链接</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2014/11/compiler.html</a></p>
<p>Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking)</p>
<p>以c语言为例:</p>
<h3 id="1-预处理"><a href="#1-预处理" class="headerlink" title="1 预处理"></a>1 预处理</h3><p>预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有：</p>
<ol>
<li>将所有的“#define”删除，并展开所用的宏定义</li>
<li>处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif”</li>
<li>处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的</li>
<li>删除所有注释</li>
<li>添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号</li>
<li>保留所有的#pragma编译器指令。</li>
</ol>
<h3 id="2-编译"><a href="#2-编译" class="headerlink" title="2 编译"></a>2 编译</h3><p>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。</p>
<h3 id="3-汇编"><a href="#3-汇编" class="headerlink" title="3 汇编"></a>3 汇编</h3><p>汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File)</p>
<h3 id="4-链接"><a href="#4-链接" class="headerlink" title="4 链接"></a>4 链接</h3><p>链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。<br>链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。</p>
<h2 id="5-静态链接和动态链接"><a href="#5-静态链接和动态链接" class="headerlink" title="5 静态链接和动态链接"></a>5 静态链接和动态链接</h2><p>静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来<br>静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库</p>
<p>动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序</p>
<h2 id="6-虚拟内存技术"><a href="#6-虚拟内存技术" class="headerlink" title="6 虚拟内存技术"></a>6 虚拟内存技术</h2><p>虚拟存储器是值具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统.</p>
<h2 id="7-分页和分段"><a href="#7-分页和分段" class="headerlink" title="7 分页和分段"></a>7 分页和分段</h2><p>分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p>
<p>分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。</p>
<h3 id="分页与分段的主要区别"><a href="#分页与分段的主要区别" class="headerlink" title="分页与分段的主要区别"></a>分页与分段的主要区别</h3><ol>
<li>页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</li>
<li>页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</li>
<li>分页的作业地址空间是一维的.分段的地址空间是二维的.</li>
</ol>
<h2 id="8-页面置换算法"><a href="#8-页面置换算法" class="headerlink" title="8 页面置换算法"></a>8 页面置换算法</h2><ol>
<li>最佳置换算法OPT:不可能实现</li>
<li>先进先出FIFO</li>
<li>最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换.</li>
<li>clock算法</li>
</ol>
<h2 id="9-边沿触发和水平触发"><a href="#9-边沿触发和水平触发" class="headerlink" title="9 边沿触发和水平触发"></a>9 边沿触发和水平触发</h2><p>边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1 事务"></a>1 事务</h2><p>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。</p>
<h2 id="2-数据库索引"><a href="#2-数据库索引" class="headerlink" title="2 数据库索引"></a>2 数据库索引</h2><p>推荐: <a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">http://tech.meituan.com/mysql-index.html</a></p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a></p>
<p>聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理</p>
<h2 id="3-Redis原理"><a href="#3-Redis原理" class="headerlink" title="3 Redis原理"></a>3 Redis原理</h2><h2 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4 乐观锁和悲观锁"></a>4 乐观锁和悲观锁</h2><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p>
<p>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<h2 id="5-MVCC"><a href="#5-MVCC" class="headerlink" title="5 MVCC"></a>5 MVCC</h2><h2 id="6-MyISAM和InnoDB"><a href="#6-MyISAM和InnoDB" class="headerlink" title="6 MyISAM和InnoDB"></a>6 MyISAM和InnoDB</h2><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p>
<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="1-三次握手"><a href="#1-三次握手" class="headerlink" title="1 三次握手"></a>1 三次握手</h2><ol>
<li>客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三路握手的一部分。客户端把这段连接的序号设定为随机数 A。</li>
<li>服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。</li>
<li>最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。</li>
</ol>
<h2 id="2-四次挥手"><a href="#2-四次挥手" class="headerlink" title="2 四次挥手"></a>2 四次挥手</h2><h2 id="3-ARP协议"><a href="#3-ARP协议" class="headerlink" title="3 ARP协议"></a>3 ARP协议</h2><p>地址解析协议(Address Resolution Protocol): 根据IP地址获取物理地址的一个TCP/IP协议</p>
<h2 id="4-urllib和urllib2的区别"><a href="#4-urllib和urllib2的区别" class="headerlink" title="4 urllib和urllib2的区别"></a>4 urllib和urllib2的区别</h2><p>这个面试官确实问过,当时答的urllib2可以Post而urllib不可以.</p>
<ol>
<li>urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。</li>
<li>urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。</li>
</ol>
<h2 id="5-Post和Get"><a href="#5-Post和Get" class="headerlink" title="5 Post和Get"></a>5 Post和Get</h2><p><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="external">GET和POST有什么区别？及为什么网上的多数答案都是错的</a></p>
<p>get: <a href="http://tools.ietf.org/html/rfc2616#section-9.3" target="_blank" rel="external">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a><br>post: <a href="http://tools.ietf.org/html/rfc2616#section-9.5" target="_blank" rel="external">RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1</a></p>
<h2 id="6-Cookie和Session"><a href="#6-Cookie和Session" class="headerlink" title="6 Cookie和Session"></a>6 Cookie和Session</h2><table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">Cookie</th>
<th style="text-align:left">Session</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">储存位置</td>
<td style="text-align:left">客户端</td>
<td style="text-align:left">服务器端</td>
</tr>
<tr>
<td style="text-align:left">目的</td>
<td style="text-align:left">跟踪会话，也可以保存用户偏好设置或者保存用户名密码等</td>
<td style="text-align:left">跟踪会话</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">不安全</td>
<td style="text-align:left">安全</td>
</tr>
</tbody>
</table>
<p>session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。</p>
<h2 id="7-apache和nginx的区别"><a href="#7-apache和nginx的区别" class="headerlink" title="7 apache和nginx的区别"></a>7 apache和nginx的区别</h2><p>nginx 相对 apache 的优点：</p>
<ul>
<li>轻量级，同样起web 服务，比apache 占用更少的内存及资源</li>
<li>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能</li>
<li>配置简洁</li>
<li>高度模块化的设计，编写模块相对简单</li>
<li>社区活跃</li>
</ul>
<p>apache 相对nginx 的优点：</p>
<ul>
<li>rewrite ，比nginx 的rewrite 强大</li>
<li>模块超多，基本想到的都可以找到</li>
<li>少bug ，nginx 的bug 相对较多</li>
<li>超稳定</li>
</ul>
<h2 id="8-网站用户密码保存"><a href="#8-网站用户密码保存" class="headerlink" title="8 网站用户密码保存"></a>8 网站用户密码保存</h2><ol>
<li>明文保存</li>
<li>明文hash后保存,如md5</li>
<li>MD5+Salt方式,这个salt可以随机</li>
<li>知乎使用了Bcrypy(好像)加密</li>
</ol>
<h2 id="9-HTTP和HTTPS"><a href="#9-HTTP和HTTPS" class="headerlink" title="9 HTTP和HTTPS"></a>9 HTTP和HTTPS</h2><table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1xx 报告</td>
<td style="text-align:left">接收到请求，继续进程</td>
</tr>
<tr>
<td style="text-align:left">2xx 成功</td>
<td style="text-align:left">步骤成功接收，被理解，并被接受</td>
</tr>
<tr>
<td style="text-align:left">3xx 重定向</td>
<td style="text-align:left">为了完成请求,必须采取进一步措施</td>
</tr>
<tr>
<td style="text-align:left">4xx 客户端出错</td>
<td style="text-align:left">请求包括错的顺序或不能完成</td>
</tr>
<tr>
<td style="text-align:left">5xx 服务器出错</td>
<td style="text-align:left">服务器无法完成显然有效的请求</td>
</tr>
</tbody>
</table>
<p>403: Forbidden<br>404: Not Found</p>
<p>HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA</p>
<h2 id="10-XSRF和XSS"><a href="#10-XSRF和XSS" class="headerlink" title="10 XSRF和XSS"></a>10 XSRF和XSS</h2><ul>
<li>CSRF(Cross-site request forgery)跨站请求伪造</li>
<li>XSS(Cross Site Scripting)跨站脚本攻击</li>
</ul>
<p>CSRF重点在请求,XSS重点在脚本</p>
<h2 id="11-幂等-Idempotence"><a href="#11-幂等-Idempotence" class="headerlink" title="11 幂等 Idempotence"></a>11 幂等 Idempotence</h2><p>HTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的<strong>副作用</strong>。(注意是副作用)</p>
<p><code>GET http://www.bank.com/account/123456</code>，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。<code>GET http://www.news.com/latest-news</code>这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。</p>
<p>DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：<code>DELETE http://www.forum.com/article/4231</code>，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。</p>
<p>POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：<code>POST http://www.forum.com/articles</code>的语义是在<code>http://www.forum.com/articles</code>下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。</p>
<p>PUT所对应的URI是要创建或更新的资源本身。比如：<code>PUT http://www.forum/articles/4231</code>的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。</p>
<h2 id="12-RESTful架构-SOAP-RPC"><a href="#12-RESTful架构-SOAP-RPC" class="headerlink" title="12 RESTful架构(SOAP,RPC)"></a>12 RESTful架构(SOAP,RPC)</h2><p>推荐: <a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<h2 id="13-SOAP"><a href="#13-SOAP" class="headerlink" title="13 SOAP"></a>13 SOAP</h2><p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。</p>
<h2 id="14-RPC"><a href="#14-RPC" class="headerlink" title="14 RPC"></a>14 RPC</h2><p>RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p>
<p>总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了.</p>
<p>进化的顺序: RPC -&gt; SOAP -&gt; RESTful</p>
<h2 id="15-CGI和WSGI"><a href="#15-CGI和WSGI" class="headerlink" title="15 CGI和WSGI"></a>15 CGI和WSGI</h2><p>CGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。<br>CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。</p>
<p>WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。</p>
<p>官方说明：<a href="https://www.python.org/dev/peps/pep-3333/" target="_blank" rel="external">PEP-3333</a></p>
<h2 id="16-中间人攻击"><a href="#16-中间人攻击" class="headerlink" title="16 中间人攻击"></a>16 中间人攻击</h2><p>在GFW里屡见不鲜的,呵呵.</p>
<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<h2 id="17-c10k问题"><a href="#17-c10k问题" class="headerlink" title="17 c10k问题"></a>17 c10k问题</h2><p>所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。<br>推荐: <a href="http://www.kegel.com/c10k.html" target="_blank" rel="external">http://www.kegel.com/c10k.html</a></p>
<h2 id="18-socket"><a href="#18-socket" class="headerlink" title="18 socket"></a>18 socket</h2><p>推荐: <a href="http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml" target="_blank" rel="external">http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml</a></p>
<p>Socket=Ip address+ TCP/UDP + port</p>
<h2 id="19-浏览器缓存"><a href="#19-浏览器缓存" class="headerlink" title="19 浏览器缓存"></a>19 浏览器缓存</h2><p>推荐: <a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="external">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>304 Not Modified</p>
<h2 id="20-HTTP1-0和HTTP1-1"><a href="#20-HTTP1-0和HTTP1-1" class="headerlink" title="20 HTTP1.0和HTTP1.1"></a>20 HTTP1.0和HTTP1.1</h2><p>推荐: <a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="external">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<ol>
<li>请求头Host字段,一个服务器多个网站</li>
<li>长链接</li>
<li>文件断点续传</li>
<li>身份认证,状态管理,Cache缓存</li>
</ol>
<h2 id="21-Ajax"><a href="#21-Ajax" class="headerlink" title="21 Ajax"></a>21 Ajax</h2><p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p>
<h1 id="NIX"><a href="#NIX" class="headerlink" title="*NIX"></a>*NIX</h1><h2 id="unix进程间通信方式-IPC"><a href="#unix进程间通信方式-IPC" class="headerlink" title="unix进程间通信方式(IPC)"></a>unix进程间通信方式(IPC)</h2><ol>
<li>管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。</li>
<li>命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。</li>
<li>信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。</li>
<li>消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li>
<li>共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。</li>
<li>内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。</li>
<li>信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。</li>
<li>套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</li>
</ol>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1 红黑树"></a>1 红黑树</h2><p>红黑树与AVL的比较：</p>
<p>AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多；</p>
<p>红黑是用非严格的平衡来换取增删节点时候旋转次数的降低；</p>
<p>所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="1-台阶问题-斐波纳挈"><a href="#1-台阶问题-斐波纳挈" class="headerlink" title="1 台阶问题/斐波纳挈"></a>1 台阶问题/斐波纳挈</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt;= <span class="number">2</span> <span class="keyword">else</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>第二种记忆方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memo</span><span class="params">(func)</span>:</span></span><br><span class="line">    cache = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">not</span> <span class="keyword">in</span> cache:</span><br><span class="line">            cache[args] = func(*args)</span><br><span class="line">        <span class="keyword">return</span> cache[args]</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@memo</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(i<span class="number">-1</span>) + fib(i<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>
<p>第三种方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> b</span><br></pre></td></tr></table></figure>
<h2 id="2-变态台阶问题"><a href="#2-变态台阶问题" class="headerlink" title="2 变态台阶问题"></a>2 变态台阶问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib = <span class="keyword">lambda</span> n: n <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> <span class="number">2</span> * fib(n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="3-矩形覆盖"><a href="#3-矩形覆盖" class="headerlink" title="3 矩形覆盖"></a>3 矩形覆盖</h2><p>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？</p>
<blockquote>
<p>第<code>2*n</code>个矩形的覆盖方法等于第<code>2*(n-1)</code>加上第<code>2*(n-2)</code>的方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> n: <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h2 id="4-杨氏矩阵查找"><a href="#4-杨氏矩阵查找" class="headerlink" title="4 杨氏矩阵查找"></a>4 杨氏矩阵查找</h2><p>在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="5-去除列表中的重复元素"><a href="#5-去除列表中的重复元素" class="headerlink" title="5 去除列表中的重复元素"></a>5 去除列表中的重复元素</h2><p>用集合</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(l))</span><br></pre></td></tr></table></figure>
<p>用字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = &#123;&#125;.fromkeys(l1).keys()</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure>
<p>用字典并保持顺序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = list(set(l1))</span><br><span class="line">l2.sort(key=l1.index)</span><br><span class="line"><span class="keyword">print</span> l2</span><br></pre></td></tr></table></figure>
<p>列表推导式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'a'</span>,<span class="string">'a'</span>]</span><br><span class="line">l2 = []</span><br><span class="line">[l2.append(i) <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> <span class="keyword">not</span> i <span class="keyword">in</span> l2]</span><br></pre></td></tr></table></figure>
<p>面试官提到的,先排序然后删除.</p>
<h2 id="6-链表成对调换"><a href="#6-链表成对调换" class="headerlink" title="6 链表成对调换"></a>6 链表成对调换</h2><p><code>1-&gt;2-&gt;3-&gt;4</code>转换成<code>2-&gt;1-&gt;4-&gt;3</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param a ListNode</span></span><br><span class="line">    <span class="comment"># @return a ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> head != <span class="keyword">None</span> <span class="keyword">and</span> head.next != <span class="keyword">None</span>:</span><br><span class="line">            next = head.next</span><br><span class="line">            head.next = self.swapPairs(next.next)</span><br><span class="line">            next.next = head</span><br><span class="line">            <span class="keyword">return</span> next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h2 id="7-创建字典的方法"><a href="#7-创建字典的方法" class="headerlink" title="7 创建字典的方法"></a>7 创建字典的方法</h2><h3 id="1-直接创建"><a href="#1-直接创建" class="headerlink" title="1 直接创建"></a>1 直接创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict = &#123;<span class="string">'name'</span>:<span class="string">'earth'</span>, <span class="string">'port'</span>:<span class="string">'80'</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-工厂方法"><a href="#2-工厂方法" class="headerlink" title="2 工厂方法"></a>2 工厂方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">items=[(<span class="string">'name'</span>,<span class="string">'earth'</span>),(<span class="string">'port'</span>,<span class="string">'80'</span>)]</span><br><span class="line">dict2=dict(items)</span><br><span class="line">dict1=dict(([<span class="string">'name'</span>,<span class="string">'earth'</span>],[<span class="string">'port'</span>,<span class="string">'80'</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="3-fromkeys-方法"><a href="#3-fromkeys-方法" class="headerlink" title="3 fromkeys()方法"></a>3 fromkeys()方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict1=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>),<span class="number">-1</span>)</span><br><span class="line">dict=&#123;<span class="string">'x'</span>:<span class="number">-1</span>,<span class="string">'y'</span>:<span class="number">-1</span>&#125;</span><br><span class="line">dict2=&#123;&#125;.fromkeys((<span class="string">'x'</span>,<span class="string">'y'</span>))</span><br><span class="line">dict2=&#123;<span class="string">'x'</span>:<span class="keyword">None</span>, <span class="string">'y'</span>:<span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-合并两个有序列表"><a href="#8-合并两个有序列表" class="headerlink" title="8 合并两个有序列表"></a>8 合并两个有序列表</h2><p>知乎远程面试要求编程</p>
<p>尾递归</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_recursion_merge_sort2</span><span class="params">(l1, l2, tmp)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(l1) == <span class="number">0</span> <span class="keyword">or</span> len(l2) == <span class="number">0</span>:</span><br><span class="line">        tmp.extend(l1)</span><br><span class="line">        tmp.extend(l2)</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> l1[<span class="number">0</span>] &lt; l2[<span class="number">0</span>]:</span><br><span class="line">            tmp.append(l1[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l1[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(l2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">del</span> l2[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, tmp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recursion_merge_sort2</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> _recursion_merge_sort2(l1, l2, [])</span><br></pre></td></tr></table></figure>
<p>循环算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def loop_merge_sort(l1, l2):</span><br><span class="line">    tmp = []</span><br><span class="line">    while len(l1) &gt; 0 and len(l2) &gt; 0:</span><br><span class="line">        if l1[0] &lt; l2[0]:</span><br><span class="line">            tmp.append(l1[0])</span><br><span class="line">            del l1[0]</span><br><span class="line">        else:</span><br><span class="line">            tmp.append(l2[0])</span><br><span class="line">            del l2[0]</span><br><span class="line">    tmp.extend(l1)</span><br><span class="line">    tmp.extend(l2)</span><br><span class="line">    return tmp</span><br></pre></td></tr></table></figure>
<h2 id="9-交叉链表求交点"><a href="#9-交叉链表求交点" class="headerlink" title="9 交叉链表求交点"></a>9 交叉链表求交点</h2><p>去哪儿的面试,没做出来.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node</span><span class="params">(l1, l2)</span>:</span></span><br><span class="line">    length1, lenth2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># 求两个链表长度</span></span><br><span class="line">    <span class="keyword">while</span> l1.next:</span><br><span class="line">        l1 = l1.next</span><br><span class="line">        length1 += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l2.next:</span><br><span class="line">        l2 = l2.next</span><br><span class="line">        length2 += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 长的链表先走</span></span><br><span class="line">    <span class="keyword">if</span> length1 &gt; lenth2:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length1 - length2):</span><br><span class="line">            l1 = l1.next</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(length2 - length1):</span><br><span class="line">            l2 = l2.next</span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.next == l2.next:</span><br><span class="line">            <span class="keyword">return</span> l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l1 = l1.next</span><br><span class="line">            l2 = l2.next</span><br></pre></td></tr></table></figure>
<h2 id="10-二分查找"><a href="#10-二分查找" class="headerlink" title="10 二分查找"></a>10 二分查找</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(l, t)</span>:</span></span><br><span class="line">    low, high = <span class="number">0</span>, len(l) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        <span class="keyword">print</span> low, high</span><br><span class="line">        mid = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> l[mid] &gt; t:</span><br><span class="line">            high = mid</span><br><span class="line">        <span class="keyword">elif</span> l[mid] &lt; t:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">    <span class="keyword">return</span> low <span class="keyword">if</span> l[low] == t <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">120</span>, <span class="number">444</span>]</span><br><span class="line">    <span class="keyword">print</span> binarySearch(l, <span class="number">12</span>)</span><br><span class="line">    <span class="keyword">print</span> binarySearch(l, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">print</span> binarySearch(l, <span class="number">13</span>)</span><br><span class="line">    <span class="keyword">print</span> binarySearch(l, <span class="number">444</span>)</span><br></pre></td></tr></table></figure>
<h2 id="11-快排"><a href="#11-快排" class="headerlink" title="11 快排"></a>11 快排</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsort</span><span class="params">(seq)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> seq==[]:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot=seq[<span class="number">0</span>]</span><br><span class="line">        lesser=qsort([x <span class="keyword">for</span> x <span class="keyword">in</span> seq[<span class="number">1</span>:] <span class="keyword">if</span> x&lt;pivot])</span><br><span class="line">        greater=qsort([x <span class="keyword">for</span> x <span class="keyword">in</span> seq[<span class="number">1</span>:] <span class="keyword">if</span> x&gt;=pivot])</span><br><span class="line">        <span class="keyword">return</span> lesser+[pivot]+greater</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    seq=[<span class="number">5</span>,<span class="number">6</span>,<span class="number">78</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">-65</span>,<span class="number">12</span>]</span><br><span class="line">    print(qsort(seq))</span><br></pre></td></tr></table></figure>
<h2 id="12-找零问题"><a href="#12-找零问题" class="headerlink" title="12 找零问题"></a>12 找零问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">coinChange</span><span class="params">(values, money, coinsUsed)</span>:</span></span><br><span class="line">    <span class="comment">#values    T[1:n]数组</span></span><br><span class="line">    <span class="comment">#valuesCounts   钱币对应的种类数</span></span><br><span class="line">    <span class="comment">#money  找出来的总钱数</span></span><br><span class="line">    <span class="comment">#coinsUsed   对应于目前钱币总数i所使用的硬币数目</span></span><br><span class="line">    <span class="keyword">for</span> cents <span class="keyword">in</span> range(<span class="number">1</span>, money+<span class="number">1</span>):</span><br><span class="line">        minCoins = cents     <span class="comment">#从第一个开始到money的所有情况初始</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">            <span class="keyword">if</span> value &lt;= cents:</span><br><span class="line">                temp = coinsUsed[cents - value] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> temp &lt; minCoins:</span><br><span class="line">                    minCoins = temp</span><br><span class="line">        coinsUsed[cents] = minCoins</span><br><span class="line">        print(<span class="string">'面值为：&#123;0&#125; 的最小硬币数目为：&#123;1&#125; '</span>.format(cents, coinsUsed[cents]) )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    values = [ <span class="number">25</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">1</span>]</span><br><span class="line">    money = <span class="number">63</span></span><br><span class="line">    coinsUsed = &#123;i:<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(money+<span class="number">1</span>)&#125;</span><br><span class="line">    coinChange(values, money, coinsUsed)</span><br></pre></td></tr></table></figure>
<h2 id="13-广度遍历和深度遍历二叉树"><a href="#13-广度遍历和深度遍历二叉树" class="headerlink" title="13 广度遍历和深度遍历二叉树"></a>13 广度遍历和深度遍历二叉树</h2><p>给定一个数组，构建二叉树，并且按层次打印这个二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 14 二叉树节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data, left=None, right=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line">tree = Node(<span class="number">1</span>, Node(<span class="number">3</span>, Node(<span class="number">7</span>, Node(<span class="number">0</span>)), Node(<span class="number">6</span>)), Node(<span class="number">2</span>, Node(<span class="number">5</span>), Node(<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 15 层次遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lookup</span><span class="params">(root)</span>:</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        current = stack.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">print</span> current.data</span><br><span class="line">        <span class="keyword">if</span> current.left:</span><br><span class="line">            stack.append(current.left)</span><br><span class="line">        <span class="keyword">if</span> current.right:</span><br><span class="line">            stack.append(current.right)</span><br><span class="line"><span class="comment">## 16 深度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">print</span> root.data</span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lookup(tree)</span><br><span class="line">    deep(tree)</span><br></pre></td></tr></table></figure>
<h2 id="17-前中后序遍历"><a href="#17-前中后序遍历" class="headerlink" title="17 前中后序遍历"></a>17 前中后序遍历</h2><p>深度遍历改变顺序就OK了</p>
<h2 id="18-求最大树深"><a href="#18-求最大树深" class="headerlink" title="18 求最大树深"></a>18 求最大树深</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="19-求两棵树是否相同"><a href="#19-求两棵树是否相同" class="headerlink" title="19 求两棵树是否相同"></a>19 求两棵树是否相同</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(p, q)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="keyword">None</span> <span class="keyword">and</span> q == <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">elif</span> p <span class="keyword">and</span> q :</span><br><span class="line">        <span class="keyword">return</span> p.val == q.val <span class="keyword">and</span> isSameTree(p.left,q.left) <span class="keyword">and</span> isSameTree(p.right,q.right)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<h2 id="20-前序中序求后序"><a href="#20-前序中序求后序" class="headerlink" title="20 前序中序求后序"></a>20 前序中序求后序</h2><p>推荐: <a href="http://blog.csdn.net/hinyunsin/article/details/6315502" target="_blank" rel="external">http://blog.csdn.net/hinyunsin/article/details/6315502</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rebuild</span><span class="params">(pre, center)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pre:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    cur = Node(pre[<span class="number">0</span>])</span><br><span class="line">    index = center.index(pre[<span class="number">0</span>])</span><br><span class="line">    cur.left = rebuild(pre[<span class="number">1</span>:index + <span class="number">1</span>], center[:index])</span><br><span class="line">    cur.right = rebuild(pre[index + <span class="number">1</span>:], center[index + <span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> cur</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deep</span><span class="params">(root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    deep(root.left)</span><br><span class="line">    deep(root.right)</span><br><span class="line">    <span class="keyword">print</span> root.data</span><br></pre></td></tr></table></figure>
<h2 id="21-单链表逆置"><a href="#21-单链表逆置" class="headerlink" title="21 单链表逆置"></a>21 单链表逆置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data=None, next=None)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line"></span><br><span class="line">link = Node(<span class="number">1</span>, Node(<span class="number">2</span>, Node(<span class="number">3</span>, Node(<span class="number">4</span>, Node(<span class="number">5</span>, Node(<span class="number">6</span>, Node(<span class="number">7</span>, Node(<span class="number">8</span>, Node(<span class="number">9</span>)))))))))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rev</span><span class="params">(link)</span>:</span></span><br><span class="line">    pre = link</span><br><span class="line">    cur = link.next</span><br><span class="line">    pre.next = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line">root = rev(link)</span><br><span class="line"><span class="keyword">while</span> root:</span><br><span class="line">    <span class="keyword">print</span> root.data</span><br><span class="line">    root = root.next</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/07/怎样才能敢说你熟悉python？/" data-id="cimuooa8h00095ieldxhktkyz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-ML数学基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/06/ML数学基础/" class="article-date">
  <time datetime="2016-04-06T02:27:23.000Z" itemprop="datePublished">2016-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/06/ML数学基础/">ML数学基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ML数学基础"><a href="#ML数学基础" class="headerlink" title="ML数学基础"></a>ML数学基础</h3><ul>
<li><h4 id="一，jensen不等式"><a href="#一，jensen不等式" class="headerlink" title="一，jensen不等式"></a>一，jensen不等式</h4><img src="http://7xskxa.com2.z0.glb.clouddn.com/jassen%E4%B8%8D%E7%AD%89%E5%BC%8F.jpg" alt="jensen公式"></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/06/ML数学基础/" data-id="cimuooa7u00015ielgepp2o9n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java读写文件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/05/java读写文件/" class="article-date">
  <time datetime="2016-04-05T14:15:17.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/java读写文件/">java读写文件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="java读写文件"><a href="#java读写文件" class="headerlink" title="java读写文件"></a>java读写文件</h3><ul>
<li><h4 id="参考网站："><a href="#参考网站：" class="headerlink" title="参考网站："></a>参考网站：</h4><pre><code>http://blog.csdn.net/sunnyfans/article/details/7706700
</code></pre><p>  不带缓冲的操作，每读一个字节就要写入一个字节，由于涉及磁盘的IO操作相比内存的操作要慢很多，所以不带缓冲的流效率很低。<br>带缓冲的流，可以一次读很多字节，但不向磁盘中写入，只是先放到内存里。等凑够了缓冲区大小的时候一次性写入磁盘，这种方式可以减<br>少磁盘操作次数，速度就会提高很多！这就是两者的区别</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/05/java读写文件/" data-id="cimuooa8a00075iel1ef0cl4o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-统计学习方法读书笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/05/统计学习方法读书笔记/" class="article-date">
  <time datetime="2016-04-05T11:54:32.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/统计学习方法读书笔记/">统计学习方法读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第三章-朴素贝叶斯方法"><a href="#第三章-朴素贝叶斯方法" class="headerlink" title="第三章 朴素贝叶斯方法"></a>第三章 朴素贝叶斯方法</h3><ul>
<li><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><pre><code>朴素贝叶斯法是基于贝叶斯定理和特征条件独立假设的分类方法。
</code></pre></li>
<li><h4 id="公式推导："><a href="#公式推导：" class="headerlink" title="公式推导："></a>公式推导：</h4></li>
</ul>
<p><img src="http://7xskxa.com2.z0.glb.clouddn.com/bays.jpg" alt="bays"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$ P(Y=c_&#123;k&#125;|X=x)=\frac&#123;P(X=x|Y=c_&#123;k&#125;)P(Y=c_&#123;k&#125;)&#125;&#123;\sum_k&#123;P(X=x|Y=c_&#123;k&#125;)P(Y=c_&#123;k&#125;)&#125;&#125;$$</span><br><span class="line">$$               =\frac&#123;P(Y=c_&#123;k&#125;)\prod_jP(&#123;X^&#123;(j)&#125;=x^&#123;(j)&#125;|Y=c_k)&#125;&#125;&#123;\sum_k&#123;上式&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<pre><code>那么贝叶斯分类器可表示为：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$               y=f(x)=P(Y=c_&#123;k&#125;|X=x)=&#123;argmax&#125;_&#123;c_k&#125; \frac&#123;P(Y=c_&#123;k&#125;)\prod_jP(&#123;X^&#123;(j)&#125;=x^&#123;(j)&#125;|Y=c_k)&#125;&#125;&#123;\sum_k&#123;上式&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="后验概率最大化及参数估计"><a href="#后验概率最大化及参数估计" class="headerlink" title="后验概率最大化及参数估计"></a>后验概率最大化及参数估计</h4></li>
<li><h5 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$ </span><br><span class="line">      P(Y=c_&#123;k&#125;）=  \frac&#123;\sum_&#123;i=1&#125;^NI(y_i=c_k)&#125;&#123;N&#125;  $$$$</span><br><span class="line">      P(X^&#123;(j)&#125;=a_&#123;jl&#125;|Y=c_k)=  \frac&#123;\sum_&#123;i=1&#125;^NI(x_i^j=a_&#123;jl&#125;,y_i=c_k)&#125;&#123;\sum_&#123;i=1&#125;^NI(y_i=c_k)&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="贝叶斯估计（补充概率值为零的情况）"><a href="#贝叶斯估计（补充概率值为零的情况）" class="headerlink" title="贝叶斯估计（补充概率值为零的情况）"></a>贝叶斯估计（补充概率值为零的情况）</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$$ </span><br><span class="line">      P(Y=c_&#123;k&#125;）=  \frac&#123;\sum_&#123;i=1&#125;^NI(y_i=c_k)&#125;&#123;N&#125;  $$$$</span><br><span class="line">      P(X^&#123;(j)&#125;=a_&#123;jl&#125;|Y=c_k)=  \frac&#123;\sum_&#123;i=1&#125;^NI(x_i^j=a_&#123;jl&#125;,y_i=c_k)+\lambda&#125;&#123;\sum_&#123;i=1&#125;^NI(y_i=c_k)+S_j\lambda&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<pre><code>其中l为第l个取值， 共有S_j个取值
</code></pre><h4 id="md语法参考网址：http-ttang-name-2014-05-04-markdown-and-mathjax"><a href="#md语法参考网址：http-ttang-name-2014-05-04-markdown-and-mathjax" class="headerlink" title="md语法参考网址：http://ttang.name/2014/05/04/markdown-and-mathjax/"></a>md语法参考网址：<a href="http://ttang.name/2014/05/04/markdown-and-mathjax/" target="_blank" rel="external">http://ttang.name/2014/05/04/markdown-and-mathjax/</a></h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/05/统计学习方法读书笔记/" data-id="cimuooa8w000d5ielr1j9rjpd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-正则表达式背诵" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/05/正则表达式背诵/" class="article-date">
  <time datetime="2016-04-05T10:36:56.000Z" itemprop="datePublished">2016-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/05/正则表达式背诵/">正则表达式背诵</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="正则表达式背诵"><a href="#正则表达式背诵" class="headerlink" title="正则表达式背诵"></a><strong>正则表达式背诵</strong></h2><pre><code>参考网址：http://www.php100.com/manual/unze.html
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/05/正则表达式背诵/" data-id="cimuooa8s000b5ielgigb8l7m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-深入理解java异常处理机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/04/深入理解java异常处理机制/" class="article-date">
  <time datetime="2016-04-04T14:16:25.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/深入理解java异常处理机制/">深入理解java异常处理机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="深入理解java异常处理机制"><a href="#深入理解java异常处理机制" class="headerlink" title="深入理解java异常处理机制"></a>深入理解java异常处理机制</h2><ul>
<li><h4 id="刚想学习总结一下java异常处理机制，可是就发现了这篇文章，还整理不？"><a href="#刚想学习总结一下java异常处理机制，可是就发现了这篇文章，还整理不？" class="headerlink" title="刚想学习总结一下java异常处理机制，可是就发现了这篇文章，还整理不？"></a>刚想学习总结一下java异常处理机制，可是就发现了这篇文章，还整理不？</h4><pre><code>参考文章：http://blog.csdn.net/hguisu/article/details/6155636
</code></pre></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/04/深入理解java异常处理机制/" data-id="cimuooa8u000c5ielu7xnamvu" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-java易错点总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/04/java易错点总结/" class="article-date">
  <time datetime="2016-04-04T06:52:42.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/java易错点总结/">java易错点总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="java易错点总结"><a href="#java易错点总结" class="headerlink" title="java易错点总结"></a>java易错点总结</h2><h3 id="一，java中的this-、super对比分析"><a href="#一，java中的this-、super对比分析" class="headerlink" title="一，java中的this 、super对比分析"></a>一，java中的this 、super对比分析</h3><ul>
<li><h4 id="this：总是指向调用该方法的对像，会隐式传入子类对象的引用，但是若父类方法中this指向私有方法时，私有方法将不会被覆盖（号称静态绑定-），仍然调用父类的私有方法。"><a href="#this：总是指向调用该方法的对像，会隐式传入子类对象的引用，但是若父类方法中this指向私有方法时，私有方法将不会被覆盖（号称静态绑定-），仍然调用父类的私有方法。" class="headerlink" title="this：总是指向调用该方法的对像，会隐式传入子类对象的引用，但是若父类方法中this指向私有方法时，私有方法将不会被覆盖（号称静态绑定 ），仍然调用父类的私有方法。"></a>this：总是指向调用该方法的对像，会隐式传入子类对象的引用，但是若父类方法中this指向私有方法时，私有方法将不会被覆盖（号称静态绑定 ），仍然调用父类的私有方法。</h4></li>
<li><h4 id="super：总是用于调用处方法所处的类的直接父类。"><a href="#super：总是用于调用处方法所处的类的直接父类。" class="headerlink" title="super：总是用于调用处方法所处的类的直接父类。"></a>super：总是用于调用处方法所处的类的直接父类。</h4></li>
<li><h4 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">grandfather</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"grandfather"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">father</span> <span class="keyword">extends</span> <span class="title">grandfather</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sun</span> <span class="keyword">extends</span> <span class="title">father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sun"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        <span class="keyword">super</span>.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        sun s=<span class="keyword">new</span> sun();</span><br><span class="line">        s.fun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">        sun</span><br><span class="line">        sun</span><br><span class="line">        grandfather</span><br><span class="line">        </span><br><span class="line">若father类的print为<span class="keyword">private</span> 同时不继承granfather（否则会报继承错误），则输出为：</span><br><span class="line">        sun</span><br><span class="line">        father</span><br></pre></td></tr></table></figure>
<h3 id="二，this和super的用法区别与总结"><a href="#二，this和super的用法区别与总结" class="headerlink" title="二，this和super的用法区别与总结"></a>二，this和super的用法区别与总结</h3><pre><code>1）super（参数）：调用父类的构造方法 。  
2）this（参数）：调用本类的其他构造方法。  
3）都必须放在构造方法的第一行。  
3）super：引用父类中的成员，当子类和父类中的方法重名时，这样用。  
4）this：代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，
         这时需用this来指明成员变量名）。  
5）this()和super()都指的是对象，所以，均不能在static环境中使用。包括：static变量,static方法，static语句块。  
6）从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。  
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/04/java易错点总结/" data-id="cimuooa8700055ielba4w280b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-找面包日记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/04/找面包日记/" class="article-date">
  <time datetime="2016-04-03T16:30:10.000Z" itemprop="datePublished">2016-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/04/找面包日记/">找面包日记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="找面包日记"><a href="#找面包日记" class="headerlink" title="找面包日记"></a>找面包日记</h1><h2 id="一，mysql数据库"><a href="#一，mysql数据库" class="headerlink" title="一，mysql数据库"></a>一，mysql数据库</h2><ul>
<li><h3 id="1-1，分页查询"><a href="#1-1，分页查询" class="headerlink" title="1.1，分页查询"></a>1.1，分页查询</h3><pre><code>我的解释是：数据库有一大堆符合条件查询的数据，我们限制每页显示多少条数据，这样就叫分页。
</code></pre><p><strong> 1.1.1， mysql最基本的分页查询方式：</strong></p>
<pre><code>    select * from table where xxx in (1,2,3) order by id limit #offset#, 200    
    select * from content order by id desc limit 0, 10
深坑分析：如果是limit 100000,100，需要扫描100100行，在一个高并发的应用里，每次查询需要
扫描超过10W行，性能肯定大打折扣。
</code></pre><p><strong> 1.1.2， 分页查询优化 </strong></p>
<pre><code>优化一：主键范围查找
    select * from table where xxx in (1,2,3) and id &gt;= #minId# and id &lt; #maxId#
缺点：主键分布离散、不连续时，查询命中率大幅度降低，会产生很多无用查询。

优化二：
    select * from table where id &gt;= #minId# and xxx in (1,2,3) limit 200
性能分析：这种分页方式避免了使用 limit 时候遍历 offset 带来的无谓的性能开销，避免了对 id 
使用左右范围查询时候 id 的离散分布对命中率的影响，代价是需要在内存中遍历结果集获取当前分
页中 id 的最大值，局限是只能在对全表唯一的字段做分页时使用。
</code></pre></li>
</ul>
<ul>
<li><h4 id="1-2-数据库事务"><a href="#1-2-数据库事务" class="headerlink" title="1.2 数据库事务"></a>1.2 数据库事务</h4><pre><code>每个事务使得数据库从一个一致的永久状态原子地转移到一个新的一致的永久状态，可以说，事务的ACID
(the transactional properties of Atomicity, Consistency, Isolation and 
Durability)属性是数据库事务的灵魂:
</code></pre></li>
<li><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h5><pre><code>事务的原子性首先体现在事务对数据的修改，即要么全都执行，要么全都不执行，例如，从银行账户A转一
笔款项a到账户B，结果必须是从A的账户上扣除款项a并且在B的账户上增加款项a，不能只是其中一个账户的
修改。但是，事务的原子性并不总是能够保证修改一定完成了或者一定没有进行，例如在ATM机器上进行上
述转账，转账指令提交后通信中断或者数据库主机异常了，那么转账可能完成了也可能没有进行：如果通信
中断发生前数据库主机完整接收到了转账指令且后续执行也正常，那么转账成功完成了；如果转账指令没有
到达数据库主机或者虽然到达但后续执行异常(例如写commitlog失败或者账户余额不足)，那么转账就没
有进行。要确定转账是否成功，需要待通信恢复或者数据库主机恢复后查询账户交易历史或余额。事务的
原子性也体现在事务对数据的读取上，例如一个事务对同一数据项的多次读取的结果一定是相同的。
</code></pre></li>
<li><h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><strong>一致性</strong></h5><pre><code>事务需要保持数据库数据的正确性、完整性和一致性，有些时候这种一致性由数据库的内部规则保证，例
如数据的类型必须正确，数据值必须在规定的范围内，等等；另外一些时候这种一致性由应用保证的，例
如一般情况下银行账务余额不能是负数，信用卡消费不能超过该卡的信用额度等。
</code></pre></li>
<li><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h5><pre><code>许多时候数据库在并发执行多个事务，每个事务可能需要对多个表项进行修改和查询，与此同时，更多的
查询请求可能也在执行中。数据库需要保证每一个事务在它的修改全部完成之前，对其他的事务是不可见
的，换句话说，不能让其他事务看到该事务的中间状态，例如，从银行账户A转一笔款项a到账户B，不能
让其他事务(例如账户查询)看到A账户已经扣除款项a但B账户却还没有增加款项a的状态。
</code></pre></li>
<li><h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h5><pre><code>事务完成后，它对于数据库的影响是永久性的，即使系统出现各种异常也是如此。
</code></pre></li>
</ul>
<p>出于性能考虑，许多数据库允许使用者选择牺牲隔离属性来换取并发度，从而获得性能的提升。SQL定义<br>        4种隔离级别：<br>            Read uncommitted(RU)：读取未提交的数据，即其他事务已经修改但还未commit的数据，这是最低的<br>                                  隔离级别；<br>            Read committe(RC)：在一个事务中，对同一个项，前面的读取跟后面的读取结果可能不一样，例如<br>                               第一次读取时另一个事务的修改还没有提交，第二次读取时已经提交了；<br>            Repeatable read(RR)：可重复读取，在一个事务中，对同一个项，前面的读取跟后面的读取结果一样；<br>            Serializable (S)：可序列化，即数据库的事务是可串行化执行的，就像一个事务执行的时候没有别<br>                              的事务同时在执行，这是最高的隔离级别；</p>
<pre><code>隔离级别的降低可能导致读到脏数据或者事务执行异常，例如：
    Lost update (LU)：两个事务同时修改一个数据项，但后一个事务中途失败退出，则对数据项的两个
                      修改可能都丢失；
    Dirty Reads (DR)：一个事务读取某数据项，但另一个事务更新了此数据项却没有提交，这样所有的
                      操作可能都得回滚；
    Non-repeatable Reads (NRR)：一个事务对同一数据项的多次读取可能得到不同的结果；
    Second lost updates proble(SLU)：无法重复读取的特例：两个并发事务同时读取和修改同一数据项，则后面的修改可能
                                     使得前面的修改失效；
    Phantom Reads (PR)：也称为幻读，例如在事务执行过程中，由于前面的查询和后面的查询的期间有
                        另外一个事务插入数据，后面的查询结果出现了前面查询结果中未出现的数据。
</code></pre><p>隔离级别与读写异常(不一致)的关系如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|    | LU | DR | NRR | SLU | PR |</span><br><span class="line">| RU | Y  | Y  | Y   | Y   | Y  |</span><br><span class="line">| RC | N  | N  | N   | N   | N  |</span><br><span class="line">| RR | N  | N  | N   | N   | N  |</span><br><span class="line">| S  | N  | N  | N   | N   | N  |</span><br></pre></td></tr></table></figure>
<pre><code>容易发现，在最高隔离级别serializable下，数据不会出现读写的不一致。

不同的数据库支持的隔离级别不尽相同，例如oracle只支持read  committed和serializable两个级别，MySQL支持全部四个级别。

OceanBase的事务实现与经典关系数据库有所不同，其读事务基本是分布式并发执行的，写事务目前是集
中式串行执行的，即serializable，且任何一个写事务在commit之前对其他读写事务都是不可见的，因此
OceanBase是强一致的。
</code></pre><h4 id="转发：http-blog-sina-com-cn-s-blog-3fc85e260100msz3-html"><a href="#转发：http-blog-sina-com-cn-s-blog-3fc85e260100msz3-html" class="headerlink" title="转发：http://blog.sina.com.cn/s/blog_3fc85e260100msz3.html"></a>转发：<a href="http://blog.sina.com.cn/s/blog_3fc85e260100msz3.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_3fc85e260100msz3.html</a></h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/04/找面包日记/" data-id="cimuooa8p000a5ielxcvsx22k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a href="/" class="logo">XeBin</a>
      &copy; 2016 XeBin<br>
      Powered by <a href="http://hexo.io/" target="_blank">xebin</a><br>
     <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
     <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
   </div>
  </div>
</footer>

    </div>
    

<script src="/js/jquery.min.js"></script>
<script src="/js/jquery.scrollLoading.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>